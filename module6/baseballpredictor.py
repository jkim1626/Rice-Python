"""
Sports Analytics
"""

import numeric
import codeskulptor
import math
from urllib import request
import comp140_module6 as sports

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    mat = []
    url = codeskulptor.file2url(filename)
    netfile = request.urlopen(url)
    
    for line in netfile.readlines():
        row = []
        strline = line.decode('utf-8')
        strrow = strline[:-1]
        strrow = strrow.split(", ")
        for term in strrow:
            row.append(float(term))
        mat.append(row)

    return numeric.Matrix(mat)

#print(read_matrix("comp140_analytics_simple_matrix.txt"))

def mse(result, expected):
    """
    Calculate the mean squared error between two data sets.

    The length of the inputs, result and expected, must be the same.

    inputs:
        - result: a list of integers or floats representing the actual output
        - expected: a list of integers or floats representing the predicted output

    returns: a float that is the mean squared error between the two data sets
    """
    #find difference
    combined = []
    for result_val, expected_val in zip(result, expected):
        combined.append(result_val - expected_val)
        
    #square difference
    combined_squared = []
    for num in combined: 
        combined_squared.append(num ** 2)
        
    #sum up and divide
    error = 0
    for val in combined_squared:
        error += val
    error /= len(result)

    return error

class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        predictions = inputs @ self._weights
        
        return predictions

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.

        inputs:
            - inputs: inputs: an n x m matrix of explanatory variables
            - actual_result: an n x 1 matrix of the corresponding
                             actual values for the measured variables

        Returns: a float that is the MSE between the generated
        data and the actual data
        """
        prediction = self.generate_predictions(inputs)
        
        prediction_list = []
        pred_col_len = prediction.shape()
        for ind in range(pred_col_len[0]):
            prediction_list.append(prediction[(ind,0)])
            
        results_list = []
        res_col_len = actual_result.shape()
        for ind in range(res_col_len[0]):
            results_list.append(actual_result[(ind,0)])
        
        error = mse(prediction_list, results_list)
        
        return error

def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.

    inputs:
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    first_term = input_data.transpose() @ input_data
    inverse = first_term.inverse()
    
    weights = inverse @ input_data.transpose() @ output_data
    
    return LinearModel(weights)

def soft_threshold(var_x,var_t):
    """
    Mathematical function that moves var_x closer to zero by the 
    distance var_t. If var_x moves past zero, function will return 
    zero.
    
    inputs:
        - var_x: an integer that needs minimizing
        - var_t: an integer representing step size
        
    returns: an integer that is a value closer to zero than var_x
    """
    if math.fabs(var_x) <= var_t:
        return 0
    elif var_x > var_t:
        res = var_x - var_t
    elif var_x < (var_t * -1):
        res = var_x + var_t
    return res

def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix using the LASSO method.

    inputs:
        - param: a float representing the lambda parameter
        - iterations: an integer representing the number of iterations
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    weights = fit_least_squares(input_data, output_data)
    weights_mat = weights.get_weights()
    rep = 0
    num_part1 = (input_data.transpose()) @ output_data
    num_inner_part2 = (input_data.transpose()) @ input_data
    
    while rep < iterations:
        weights_old = weights_mat.copy()
        dim = input_data.shape()
        for ind in range(dim[1]):
            num_outer_part2 = ((num_inner_part2.getrow(ind)) @ weights_mat)
            numerator_a = num_part1[(ind,0)] - num_outer_part2[(0,0)]
            denom_a = num_inner_part2[(ind,ind)]
            val_a = numerator_a / denom_a
            
            denom_b = 2 * num_inner_part2[(ind,ind)]
            val_b = param / denom_b
            
            weights_mat[(ind,0)] = soft_threshold(weights_mat[(ind,0)] + val_a, val_b)
        weights_diff = weights_mat - weights_old
        if weights_diff.abs().summation() < 10 ** (-5):
            break
        rep += 1
    
    return LinearModel(weights_mat)

def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.

    inputs:
        - iterations: an integer representing the number of iterations to use

    Print out the model's prediction error on the two data sets
    """
    # read in data 
    stats = read_matrix("comp140_analytics_baseball.txt")
    wins = read_matrix("comp140_analytics_wins.txt")
    test_stats = read_matrix("comp140_analytics_baseball_test.txt")
    test_wins = read_matrix("comp140_analytics_wins_test.txt")
    
    # least squares estimate
    least_squares_model = fit_least_squares(stats, wins)
    
    # LASSO estimate
    lasso_model1000 = fit_lasso(1000, iterations, stats, wins)
    lasso_model10000 = fit_lasso(10000, iterations, stats, wins)
    lasso_model100000 = fit_lasso(100000, iterations, stats, wins)
    
    # model prediction errors for training data
    print(least_squares_model.prediction_error(stats, wins))
    
    print(lasso_model1000.prediction_error(stats, wins))
    print(lasso_model10000.prediction_error(stats, wins))
    print(lasso_model100000.prediction_error(stats, wins))
    
    # model prediction errors for test data 
    print(least_squares_model.prediction_error(test_stats, test_wins))
   
    print(lasso_model1000.prediction_error(test_stats, test_wins))
    print(lasso_model10000.prediction_error(test_stats, test_wins))
    print(lasso_model100000.prediction_error(test_stats, test_wins))
    

run_experiment(750)